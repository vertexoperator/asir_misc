/*
partial implementation of algorithms described in

"Using Extended Derksen Ideals in Computational Invariant Theory"
http://arxiv.org/abs/1310.6851

algorithm 6.1/7.1/7.2 is implemented.

examples:

linvar([x*y-1] , newmat(3,3,[[x,0,0],[0,x^2,0],[0,0,y]]),[t1,t2,t3]);

linvar([c*c+s*s-1] , newmat(2,2,[[c,s],[-s,c]]) , [x,y]);

linvar([c*c+s*s-1] , newmat(4,4,[[c,s,0,0],[-s,c,0,0],[0,0,c,s],[0,0,-s,c]]) , [q1,q2,p1,p2]);

linvar([c*c+s*s-1] ,
        newmat(7,7,[[c,s,0,0,0,0,a],
                    [-s,c,0,0,0,0,b],
                    [0,0,c,s,0,0,a],
                    [0,0,-s,c,0,0,b],
                    [0,0,0,0,c,s,a],
                    [0,0,0,0,-s,c,b],
                    [0,0,0,0,0,0,1]]) ,
        [x1,y1,x2,y2,x3,y3,z]);


linvar([a*d-b*c-1] , newmat(3,3,[[a^2 , 2*a*b , b^2],[a*c , a*d+b*c , b*d],[c^2 ,2*c*d ,d^2]]) , [x,y,z]);

*/
load("noro_pd.rr");
load("noro_matrix.rr");

def memq(Obj , Ls){
  for(C=Ls;C!=[];C=cdr(C)){
     if(Obj==car(C))return 1;
  }
  return 0;
}

def union(Ls , Rs){
   Ret = [];
   for(C=append(Ls,Rs) ; C!=[] ; C=cdr(C)){
      It = car(C);
      if( !memq(It,Ret) )Ret=cons(It , Ret);
   }
   return Ret;
}

def intersect(Ls , Rs){
    Ret = [];
    for(C=Ls;C!=[];C=cdr(C)){
       if(memq(car(C) , Rs))Ret=cons(car(C) , Ret);
    }
    return Ret;
}

def diffset(Ls , Rs){
   Ret = [];
   for(C=Ls;C!=[];C=cdr(C)){
      if(memq(car(C) , Rs))continue;
      Ret = cons(car(C) , Ret);
   }
   return Ret;
}

def tdeg(F , Xs){
   Ret = 0;
   for(V = dp_ptod(F,Xs) ; V ; V = dp_rest(V)){
      D = 0;
      for(I = 0 ; I < length(Xs) ; I++){
         D = D + deg(dp_dtop(dp_ht(V) , Xs) , Xs[I]);
      }
      if(D > Ret)Ret=D;
   }
   return Ret;
}

def max(Ls){
   V = 0;
   for(Ls=Ls ; Ls!=[] ; Ls=cdr(Ls)){
      if(car(Ls) > V)V=car(Ls);
   }
   return V;
}


/*
多項式P中の単項式Mの係数を計算する
monocoef(y^3+x^3*y^2+2*x*y^2+2*x*y , x*y^2 , [x,y]);
なら、2を返す
monocoef(y^3+x^3*y^2+2*y^2+2*x*y , y^2 , [y]);
なら、x^3+2
monocoef(y^3+x^3*y^2+2*y^2+2*x*y , x*y^2 , [y]);
でも、x^3+2
*/
def monocoef(P,M,V){
   if( nmono(M)!=1 )return 0;
   HT = dp_ht(dp_ptod(M , V));
   for(T = dp_ptod(P,V) ; T ; T = dp_rest(T)){
      if(dp_ht(T)==HT)return dp_hc(T);
   }
}


def gen_monomials(Deg , V){
   if(Deg==0)return [1];
   Ret = [];
   for(C=gen_monomials(Deg-1 , V) ; C!=[] ; C=cdr(C)){
      for(I=0; I<length(V) ; I++){
         M = V[I]*car(C);
         if(!memq(M,Ret))Ret = cons(M , Ret);
      }
   }
   return Ret;
}

/*
msubst(t1 , [t1,t2,t3,t4],[t1*x^5,t2*x^3,t3*y^2,t4*y^4]);

*/
def msubst(P , Vars , Exprs){
   N = length(Vars);
   TV = [];
   TP = P;
   for(I = 0 ; I < N ; I++){
      NV = uc();
      TV = cons(NV , TV);
      TP = subst(TP , Vars[I] , NV);
   }
   TV=reverse(TV);
   for(I = 0 ; I < N ; I++){
      TP = subst(TP , TV[I] , Exprs[I]);
   }
   return TP;
}

/*
多項式係数の行列の定数係数のKernelを計算する
*/
def p_compute_kernel(PMat){
   Sz = size(PMat);
   Vars = vars(PMat);
   N = Sz[0];
   M = Sz[1];
   RPol = 0;
   for(I = 0 ; I < N ; I++){
      for(J = 0 ; J < M ; J++){
          for(V = dp_ptod(PMat[I][J] , Vars) ; V ; V=dp_rest(V)){
             RPol = RPol + dp_ht(V);
          }
      }
   }
   Terms = [];
   for(V=RPol;V;V=dp_rest(V)){Terms = cons(dp_ht(V) , Terms);}
   CMat = newmat(length(Terms)*N , M);
   for(Idx = 0 , Terms = Terms ; Terms!=[] ; Terms=cdr(Terms)){
      Term = dp_dtop(car(Terms) , Vars);
      for(W = 0 ; W < N ; W++ , Idx++){
           for(H = 0 ; H < M ; H++){
               CMat[Idx][H] = monocoef(PMat[W][H] , Term , Vars);
           }
      }
   }
   return linalg.compute_kernel(CMat);
}


/*
Algorithm 2.7 in
"Computing invariants of reductive groups in positive characteristic" by G.Kemper

IG:代数群の座標環の定義イデアル
RM:代数群の表現行列
Xs:代数群が作用する空間の座標(RMの行数/列数と等しくないといけない)
D:degree of homogeneous invariants(non-negative integer)


例:
homogeneousInvariants([a*d-b*c-1] , newmat(3,3,[[a^2 , 2*a*b , b^2],[a*c , a*d+b*c , b*d],[c^2 ,2*c*d ,d^2]]) , [x,y,z] , 2);

return [-z*x+y^2];

*/
def homogeneousInvariants(IG , RM , Xs , D){
    GVars = union(vars(IG) , vars(RM));
    AllVars = append(Xs , GVars);
    G = nd_gr(IG , GVars , 0 , 0);
    Monomials = gen_monomials(D , Xs);
    HPols = [];
    Ys = RM*ltov(Xs);
    for(C = Monomials ; C!=[] ; C=cdr(C)){
        P = car(C);
        Q = msubst(P , Xs , Ys) - P;
        HPols = cons(p_nf(Q , G , GVars , 0) , HPols);
    }
    Kernel = p_compute_kernel(newmat(1 , length(HPols) , [reverse(HPols)]));
    Ret = [];
    for(I = 0 ; I < length(Kernel) ; I++){
       P = Kernel[I][0]*matc(ltov(Monomials));
       if (P[0]!=0)Ret = cons(P[0] , Ret);
    }
    return Ret;
}



/*
step(5)(6)(7) of Algorithm 6.1 (Computation of a localization of an invariant ring)

IX:代数群が作用する空間の定義イデアル
Xs:代数群が作用する空間の座標変数
IG:代数群の座標環の定義イデアル
Zs:代数群の座標環の変数
GMaps:代数群の作用を表す多項式
*/
def rationalInvariants(GX , Xs , GY , Ys , Ord){
    Ret = [];
    CurOrd = dp_ord();
    dp_ord(Ord);   /* to get leading coefficient */
    for(RG = nd_gr_trace(GY , Ys , 1 , 1 , Ord) ; RG!=[] ; RG=cdr(RG)){
       F = p_nf(car(RG) , GX , Xs , 0); /* GX should be Groebner bases */
       if(F==0)continue;
       V = dp_ptod(F , Ys);
       LC_F = dp_hc(V);
       for(V=dp_rest(V) ; V ; V=dp_rest(V)){
          C_F = dp_hc(V);
          Q = red(C_F/LC_F);
          if(length(vars(Q))==0)continue;
          Check = 0;
          for(K=0;K<length(Ret);K++){
             R=red(Ret[K]/Q);
             if(length(vars(R))==0){
               Check=1;
               break;
             }
          }
          if(Check==0){
            Ret = cons(Q , Ret);
          }
       }
    }
    dp_ord(CurOrd);
    return Ret;
}


/*
implementation of algorithm 6.1 and algorithm 7.1
*/
def linvar(IG , RM , Xs){
   Zs = append(vars(IG) , vars(RM));
   GMaps = RM*ltov(Xs);
   /* start algorithm 6.1 */
   IX = [];
   /* step(1) is omitted */
   /* step(2) */
   Ys = [];
   GG = nd_gr(IG , Zs , 0 , 0);
   Ehat = append(IX , GG);
   for(I = 0 ; I < length(Xs) ; I++){
     YI = uc();
     Ys = cons(YI , Ys);
     Ehat = cons(YI - GMaps[I] , Ehat);
   }
   /* step(3) */
   AllVars = append(Zs , append(Ys, Xs));
   Ghat = nd_gr_trace(Ehat , AllVars , 1 , 1 , [[0,length(Zs)],[0,length(Ys)],[0,length(Xs)]]);
   G = noro_pd.elimination(Ghat , append(Xs , Ys));
   GX = noro_pd.elimination(Ghat , Xs);
   GY = diffset(G , GX);
   /* step(4) is skipped and proceed step(5)(6)(7) */
   QExprs = rationalInvariants(GX , Xs , GY , Ys , 0);
   QRats = [];
   QPols = [];
   for( ;QExprs!=[] ; QExprs=cdr(QExprs)){
      QExpr = car(QExprs);
      if(length(vars(dn(QExpr)))!=0){
         QRats = cons(QExpr , QRats);
      }else{
         QPols = cons(QExpr , QPols);
      }
   }
   /* algorithm 6.1 step(8)(9)(10) */
   if(QRats==[]){
      AP = 1;
      BPols = QPols;
   }else{
      K =length(QRats);
      Hs = map(dn , QRats);
      Fs = map(nm , QRats);
      InvPols = [];
      for(R = 1 ;; R++){
         InvPols = append(homogeneousInvariants(IG , RM , Xs , R) , InvPols);
         /* solve equations in step(9) */
         Bases = ltov(InvPols);
         for(J = 1; J < K ; J++){
              L = length(Bases);
              PMat = newvect(L+length(InvPols));
              for(I = 0 ; I < L ; I++){
                 PMat[I] = p_nf(Fs[J]*Bases[I] , GX , Xs , 0);
              }
              for(I = 0 ; I < length(InvPols) ; I++){
                 PMat[I+L] = p_nf(Hs[J]*InvPols[I] , GX , Xs , 0);
              }
              NewBases = [];
              for(Kernel = p_compute_kernel(matr(PMat)) ; Kernel!=[] ; Kernel=cdr(Kernel)){
                 V = car(Kernel)[0];
                 Pol = 0;
                 for(I = 0 ; I <L ; I++)Pol=Pol+V[I]*Bases[I];
                 if(Pol!=0)NewBases = cons(Pol , NewBases);
              }
              Bases = ltov(NewBases);
              if(length(Bases)==0)break;
         }
         if(length(Bases)>0){
             AP = Bases[0];
             break;
         }
      }
      BPols = [];
      for(J = 0 ; J < K ; J++){
         BPols = cons(red(AP*Fs[J]/Hs[J]) , BPols);
      }
      BPols = union(QPols , BPols);
      Check = 0;
      for(I = 0 ; I < length(BPols) ; I++){
         if( length(vars(red(BPols[I]/AP)))==0 ){Check=1;break;}
      }
      if(Check==0){BPols=cons(AP,BPols);}
   }
   /* start algorithm 7.1 */
   Ret = [];
   for(Deg = 1 ; ; Deg++){
      G = [];
      Ys = newvect(length(Ret));
      for(I = 0 ; I < length(Ret) ; I++){
         Ys[I] = uc();
         G = cons(Ys[I] - Ret[I] , G);
      }
      /* algorithm7.1 step(2) */
      Jhat = nd_gr(G , append(Xs , vtol(Ys)) , 0 , [[0,length(Xs)],[0,length(Ys)]]);
      J = noro_pd.elimination(Jhat , vtol(Ys));
      Check1 = 1; /* $B \subset A$? */
      Check2 = 0; /* $K[X] \dot a \cap A= A \dot a$? */
      /* Check B \subset A */
      /*
         algorithm for subring contaiment:
         * subroutine 2.5.4 in "Algorithms in Invariant Theory" by Sturmfels
         * subroutine 2.5 in
         "Efficient computation offundamental invariants - An approach using Buchberger's Grobner bases method"
         (Sturmfels and White)
      */
      for(I = 0 ; I < length(BPols) ; I++){
         QPol = p_nf(BPols[I] , Jhat , append(Xs , vtol(Ys)) , 0);
         if( intersect(vars(QPol) , Xs)!=[] ){
             Check1 = 0;
             break;
         }
      }
      if(AP==1){
         Check2 = Check1;
      }else if(Check1==1){
         Check2 = 1;
         for(Hs = J ; Hs!=[] ; Hs=cdr(Hs)){
             HPol = red(msubst(car(Hs) , vtol(Ys) , Ret)/AP);
             if(dn(HPol)!=1){Check2=0;break;}
             QPol = p_nf(HPol , Jhat , append(Xs , vtol(Ys)) , 0);
             if( intersect(vars(QPol) , Xs)!=[] ){
                Check2 = 0;
                break;
             }
         }
      }
      if(Check2==1)return Ret;
      /* algorithm 7.2 step(3)(4) */
      for(S=homogeneousInvariants(IG,RM,Xs,Deg) ; S!=[] ; S=cdr(S)){
         SPol = p_nf(car(S) , Jhat , append(Xs , vtol(Ys)) , 0);
         if( intersect(vars(SPol) , Xs)!=[] ){
            Ret = cons(car(S), Ret);
         }
      }
   }
}

